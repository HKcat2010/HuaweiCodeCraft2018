# HuaweiCodeCraft2019
队员：黄楷 

先说思路

step 1 :
刚开始的图肯定是要建出来的，考虑到是稠密的图(题目需要任意两点间的最小代价路径)，我选择邻接矩阵的表示方法，元素是路径的链表指针。
同时查阅了很多的动态规划的理论，觉得Floyd应该是最合适建立地图的，同时我把代价函数设为 
cost = sigma(length of road / min(max_car_speed, road_limit_speed)) 
得到的是最短时间的路径，同时作为下一步规划的参考
My first version of FloydSearching

step 2:
实现调度器，根据规则实现各种判题器逻辑，能够预测在哪些路口会出现死锁(A等B，B等C，C等D，D等A)的情况，从而根据给出的车辆，路口，道路条件，仿真车辆运行情况。得到私锁车辆后重新规划附近结点到目的结点的新路径(查先前的Floyd)，避免死锁
回滚到死锁之前的情况，重新仿真，直到能够解除死锁
Add Schedule Module to My Floyd Version. 

step3:
其实还考虑过网络，路由最优路径的一些算法：https://zhuanlan.zhihu.com/p/45062599 我觉得核心和动态规划的思想基本一致

补充一点最开始的时候我思考过一个问题，这个比赛的最终目的是总调度时间，那么是不是慢速车辆或行程较远的车辆拥有更高的优先级呢？因此需要给车辆分优先级：
优先程度 = w1 * 车辆出发时间 + w2 * 车辆预计行驶时间(查询Floyd表格得到) + w3 *  因死锁脱离原路径被重新规划的次数 - w4 * 所经过路径的总热度
其中路径的热度和上一次死锁状态下，道路上的拥挤程度成正相关(例如死锁状态道路上的车辆数 / 道路所能够容纳最大车辆数)
之后通过最小二乘，优化权重，得到车辆优先程度的划分，归一化后用于二次规划时选择路径的参考，比如A，B辆车死锁，那么只让A，B中优先级较低的车辆换一条路径

教训（说给我自己，大佬自动过滤）：

直到提交代码的最后的10min，还在实现调度器！！真的效率太低了,应当在有队友分工的情况下在考虑实现调度器，实际在比赛过程中也在思考，能不能跳过调度器，但是发现如果跳过就成了拿一个参数提交试一遍再改，觉得这样参赛意义不大，然而事实是连复赛都进不了，我可能还是不会取舍吧。。。

1.这种竞赛还是要组团，本身非专业基础就差，没有大佬带效率低还走弯路

2.不应该过分纠结于实现判题器！让相邻道路不出现拥堵貌似是已经能避免出现死锁了，在看完别人的代码之后再来更新对这一点的看法

3.稍微大一点的项目都需要写流程图！
 
理清思路再动手！
理清思路再动手！
理清思路再动手！
 
 一盘散沙撸完再改会浪费很多时间！！
 
 4.github做团队版本管理的重要性！
