# HuaweiCodeCraft2019
队员：黄楷 

先说思路

step 1 :
刚开始的图肯定是要建出来的，考虑到是稠密的图(题目需要任意两点间的最小代价路径)，我选择邻接矩阵的表示方法，元素是路径的链表指针。
同时查阅了很多的动态规划的理论，觉得Floyd应该是最合适建立地图的，同时我把代价函数设为 
cost = sigma(length of road / min(max_car_speed, road_limit_speed)) 
得到的是最短时间的路径，同时作为下一步规划的参考
My first version of FloydSearching

2019.4.3

新增想法，路径通行代价可以改为
 
 cost = sigma(length of road / min(max_car_speed, road_limit_speed) + 该道路路上慢车惩罚)
 
 路上慢车惩罚:
 
 switch(road_limit_speed - max_car_speed)
 
 { case 非正: 没有惩罚;break; 
   case 各负值: wi; break;}                 
 
 惩罚理由：慢车 上 快路 会押后方快车，增加惩罚项，让慢车少占用快车道，重点调参!

step 2:
实现调度器，根据规则实现各种判题器逻辑，能够预测在哪些路口会出现死锁(A等B，B等C，C等D，D等A)的情况，从而根据给出的车辆，路口，道路条件，仿真车辆运行情况。得到私锁车辆后重新规划附近结点到目的结点的新路径(查先前的Floyd)，避免死锁
回滚到死锁之前的情况，重新仿真，直到能够解除死锁
Add Schedule Module to My Floyd Version. 

step3:
其实还考虑过网络，路由最优路径的一些算法：https://zhuanlan.zhihu.com/p/45062599 我觉得核心和动态规划的思想基本一致

补充一点最开始的时候我思考过一个问题
这个比赛的最终目的是总调度时间，那么是不是慢速车辆或行程较远的车辆拥有更高的优先级呢？因此需要给车辆分优先级：

优先程度 = w1 * 车辆出发时间 + w2 * 车辆预计行驶时间(查询Floyd表格得到) + w3 *  因死锁脱离原路径被重新规划的次数 - w4 * 所经过路径的总热度

其中路径的热度和上一次死锁状态下，道路上的拥挤程度成正相关(例如死锁状态道路上的车辆数 / 道路所能够容纳最大车辆数)

通过最小二乘，优化权重，得到车辆优先程度的划分，归一化后用于二次规划时选择路径的参考，比如A，B辆车死锁，那么只让A，B中优先级较低的车辆换一条路径

经验总结：

直到提交代码的最后的10min，还在实现调度器！！效率过低,应当在有队友分工的情况下在考虑实现调度器，实际在比赛过程中也在思考，能不能跳过调度器，但是发现如果跳过就变成拿一个参数提交试一遍再改，觉得这样参赛似乎失去了意义...然而事实是连复赛都没进...

1.这种竞赛还是要组团

2.不应该过分纠结于未能视线的部分，在以竞赛为目的前提下应当先完成能完成的部分

3.流程图！！！！
